/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include <thrift/lib/cpp2/Thrift.h>
#include <thrift/lib/cpp2/protocol/Protocol.h>
#include <thrift/lib/cpp2/protocol/BinaryProtocol.h>
#include <thrift/lib/cpp2/protocol/CompactProtocol.h>
#include <thrift/lib/cpp2/protocol/DebugProtocol.h>
#include <thrift/lib/cpp2/protocol/VirtualProtocol.h>
#include <thrift/lib/cpp/protocol/TProtocol.h>
#include <thrift/lib/cpp/TApplicationException.h>
#include <folly/io/IOBuf.h>
#include <folly/io/Cursor.h>
#include <boost/operators.hpp>




namespace dnn { namespace cpp2 {

class Work;
typedef int32_t integer;

class Work : private boost::totally_ordered<Work> {
 public:

  Work() :
      n_in(0),
      c_in(0),
      w_in(0),
      h_in(0) {}
  // FragileConstructor for use in initialization lists only

  Work(apache::thrift::FragileConstructor, std::vector<double> data__arg, std::string op__arg,  ::dnn::cpp2::integer n_in__arg,  ::dnn::cpp2::integer c_in__arg,  ::dnn::cpp2::integer w_in__arg,  ::dnn::cpp2::integer h_in__arg) :
      data(std::move(data__arg)),
      op(std::move(op__arg)),
      n_in(std::move(n_in__arg)),
      c_in(std::move(c_in__arg)),
      w_in(std::move(w_in__arg)),
      h_in(std::move(h_in__arg)) {}

  Work(Work&&) = default;

  Work(const Work&) = default;

  Work& operator=(Work&&) = default;

  Work& operator=(const Work&) = default;
  void __clear();

  virtual ~Work() throw() {}

  std::vector<double> data;
  std::string op;
   ::dnn::cpp2::integer n_in;
   ::dnn::cpp2::integer c_in;
   ::dnn::cpp2::integer w_in;
   ::dnn::cpp2::integer h_in;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      data = false;
      op = false;
      n_in = false;
      c_in = false;
      w_in = false;
      h_in = false;
    }

    bool data;
    bool op;
    bool n_in;
    bool c_in;
    bool w_in;
    bool h_in;
  } __isset;
  bool operator==(const Work& rhs) const;
  bool operator < (const Work& rhs) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(Work& a, Work& b);

}} // dnn::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::dnn::cpp2::Work>::clear( ::dnn::cpp2::Work* obj) {
  return obj->__clear();
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::dnn::cpp2::Work>::write(Protocol* proto, const  ::dnn::cpp2::Work* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::dnn::cpp2::Work>::read(Protocol* proto,   ::dnn::cpp2::Work* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::dnn::cpp2::Work>::serializedSize(Protocol* proto, const  ::dnn::cpp2::Work* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::dnn::cpp2::Work>::serializedSizeZC(Protocol* proto, const  ::dnn::cpp2::Work* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace dnn { namespace cpp2 {

}} // dnn::cpp2