// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

#include "Dnn.h"
#include "caffe/caffe.hpp"

using namespace std;
using namespace apache::thrift;
using namespace apache::thrift::protocol;
using namespace apache::thrift::transport;
using namespace apache::thrift::server;

using namespace dnn;

using namespace boost;

using caffe::Blob;
using caffe::Caffe;
using caffe::Net;
using caffe::Layer;
using caffe::shared_ptr;
using caffe::Timer;
using caffe::vector;

DEFINE_bool(gpu, false, "gpu flag");
DEFINE_bool(debug, false, "debug");
DEFINE_int32(gpuid, 0, "gpuid");
DEFINE_int32(port, 8080, "server port");
DEFINE_string(net_list, "nets.txt", "file with net-configs");
DEFINE_string(net_weights, "weights/", "directory with weights");

class DnnHandler : virtual public DnnIf
{
    map<string, Net<double>* > nets;
    public:
        DnnHandler() {
            ifstream file (FLAGS_net_list.c_str());
            string net;
            while(file >> net) {
                Net<double>* temp = new Net<double>(net);
                const string name = temp->name();
                nets[name] = temp;
                string weights = FLAGS_net_weights + name + ".caffemodel";
                nets[name]->CopyTrainedLayersFrom(weights);
                nets[name]->set_debug_info(FLAGS_debug);
            }
        }

        void fwd(std::vector<double> & _return, const Work& input) {
            cout << "Task " << input.op << " foward pass.\n";
            vector<Blob<double>* > in_blobs = nets[input.op]->input_blobs();
            double* in = &input.data[0];
            in_blobs[0]->set_cpu_data(in);
            double loss;
            vector<Blob<double>* > out_blobs = nets[input.op]->ForwardPrefilled(&loss);
            for(int i = 0; i < out_blobs[0]->count();++i )
                _return.push_back(out_blobs[0]->cpu_data()[i]);

            return _return;
        }
};

int main(int argc, char **argv)
{
    google::ParseCommandLineFlags(&argc, &argv, true);

    Caffe::set_phase(Caffe::TEST);
    if(FLAGS_gpu) {
        Caffe::set_mode(Caffe::GPU);
        Caffe::SetDevice(FLAGS_gpuid);
    }
    else
        Caffe::set_mode(Caffe::CPU);

    shared_ptr<DnnHandler> handler(new DnnHandler());
    shared_ptr<TProcessor> processor(new DnnProcessor(handler));
    shared_ptr<TServerTransport> serverTransport(new TServerSocket(FLAGS_port));
    shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
    shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

    TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
    printf("Starting the server...\n");
    server.serve();
    printf("done.\n");
    return 0;
}
